Ici nous passerons en revue un ensemble de techniques exactes et approchés pour 
résolution de problèmes NP-difficiles :

\begin{itemize}
  \item problèmes d'optimisation 
  \begin{itemize}
    \item[] $\nearrow$ problèmes faciles
    \item[] $\searrow$ \fbox{problèmes NP-difficiles}
  \end{itemize}
	\item méthodes exactes 
	\begin{itemize}
		\item[] $\nearrow$ programmation dynamique
		\item[] $\searrow$ branch and bound
	\end{itemize}
	\item méthodes approchées
	\begin{itemize}
		\item[] $\longrightarrow$ algorithmes d'approximation
	\end{itemize}
\end{itemize}

Nous implémenterons aussi certains algorithmes afin de mesurer empiriquement leurs performances, et de comparer ce résultat à la complexité théorique.

\subsection{Programmation dynamique}
La programmation dynamique permet de trouver la solution optimale d'un
problème en combinant les solutions optimales de sous-problèmes de ce
problème. Ces résultats intermédiaires sont sauvegardés, souvent sous
forme matricielle, ce qui permet d'éviter de répéter des calculs inutilement.
Cependant nous sacrifiions beaucoup de mémoire pour gagner en temps de calcule.

\subsection{Branch and Bound}
Un algorithme dite de Branch and Bound, ou Séparation et Évaluation en Français, se définit à partir de trois sous-stratégies :

\begin{itemize}
\item stratégie de branchement,
\item stratégie d'évaluation,
\item stratégie d'exploration.
\end{itemize}

À chaque itération la séparation nous permet de diviser l'espace des solutions possibles en plusieurs sous ensembles, ou branches, l'évaluation permet d'éliminer certains de ceux-ci et l'exploration définit comment explorer ceux qui restent. Notons que nous devions partir d'une solution initiale, souvent obtenu en utilisant un méta-heuristique, pour définir une première borne qui servira pour l'élimination de branches. 

Contrairement à la programmation dynamique nous pouvions avoir une solution très rapidement ou très lentement selon l'instance. 

\subsection{Algorithmes d'approximation}
Les algorithmes d'approximation permettant d'apporter en temps polynomiale une
solution non-optimal à un problème NP-difficile. 

Nous étudierons ici un exemple d'algorithme approché pour le problème du 
Voyageur de Commerce qui renvoie des tours pas plus qu'une fois et demi plus
couteux que le tour optimal. Nous parlons donc de \og $\frac{3}{2}$ approximation \fg{}.
