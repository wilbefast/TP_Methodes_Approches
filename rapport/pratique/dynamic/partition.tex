%-------------------------------------------------------------------------------
% MODELISATION
%-------------------------------------------------------------------------------
\subsection{Modélisation}

Le problème de la partition se modélise de la manière suivante~:
\begin{equation}
\sum_{a \in A'} p(a)= \sum_{a \in A
    \backslash A'}p(a)
\end{equation}

%-------------------------------------------------------------------------------
% FORMULAS
%-------------------------------------------------------------------------------
\subsection{Formules de programmation dynamique}

TODO : à reprendre \\

On se basera sur la récurrence suivante~:

\begin{equation}
\begin{cases}
tab[0] = 1; \\
si ( tab[j] == 1 ) {
       tab[j + poids[i]] = 1;
     } \\
\end{cases}
\end{equation}

%-------------------------------------------------------------------------------
% ALGORITHME
%-------------------------------------------------------------------------------
\subsection{Algorithme}

\begin{algorithm}[!ht]
\caption{DP Partition}
\label{dp_partition}
\begin{algorithmic}[1]
\REQUIRE $n$ values $v_1 \dots v_n$
\STATE $total := 0$
\FOR{i from 1 to n}
	\STATE $total := total + v_i$
\ENDFOR
\IF{$total \equiv 1 [2]$}
	\RETURN $\perp$
\ENDIF
\STATE $can\_sum[0] := \top$ 
\FOR{i from 1 to n}
	\FOR{v from total/2 to 1}
		\IF{$can\_sum[i]$}
			\STATE $can\_sum[v + v_i] := \top$
		\ENDIF
	\ENDFOR
\ENDFOR
\RETURN $can\_sum[total/2]$
\end{algorithmic}
\end{algorithm}

Soit $N$ la somme des valeurs : nous devions allouer un tableau de taille $\frac{N}{2}$, donc la complexité mémoire de l'algorithme est de $O(N).$ Il faut parcourir ce tableau en entier pour chaqu'un des n valeurs, donc la complexité en temps de calcul est $O(nN)$. 


%-------------------------------------------------------------------------------
% IMPLEMENTATION
%-------------------------------------------------------------------------------
\subsection{Implémentation en C}
\label{implementation_c}
Il est important de noter l'allocation dynamique ligne 17 qui peut très facilement échouer avec des valeur choisies aléatoirement. La fonction \texttt{rand()} du C rend un entier entre $0$ et $2^{32}$, donc avec $5000$ objets nous pouvions potentiellement allouer un tableau de $10^{13}$ booléens, soit 78 téraoctets de RAM.

Malheureusement notre machine de tests n'avant que 4 gigaoctets de RAM à disposition, donc des précautions durent être prises :

\vspace{0.5cm}

\lstinputlisting[language=C,morekeywords={}]{../code/partition.c} 

%-------------------------------------------------------------------------------
% TESTS
%-------------------------------------------------------------------------------
\subsection{Tests et conclusion}

Pour les raisons explicités dans la section \ref{implementation_c} nous avions du borner les valeurs générés aléatoirement~: $50$ fut choisie comme valeur maximum. Encore une fois les valeur données sont des moyennes pour $100$ testes :

\begin{figure}[ht]
% LEFT-HAND SIDE
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{tikzpicture}[scale=0.9]
    \begin{axis}[title=Jeux de tests pour partition, xlabel= nombre d'objets, ylabel= temps d'exécution]
      \addplot
        table[col sep=comma]{../charts/partition.csv};
        %\legend{exécution de partition}
    \end{axis}
\end{tikzpicture}
\caption {Courbe des temps d'exécution pour Partition}
\end{minipage}
% RIGHT-HAND SIDE
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{tabular}[scale=0.9]{|c|c|}
\hline
Nombre d'objets & t moyenne en ms\\
\hline
150 & 1\\
\hline
500 & 14\\
\hline
650 & 24\\
\hline
800 & 32\\
\hline
950 & 43\\
\hline
1000 & 51\\
\hline
2000 & 185\\
\hline
3000 & 565\\
\hline
5000 & 1536\\
\hline
\end{tabular}
\caption {Tableau des temps d'exécution pour Partition}
\end{minipage}
\end{figure}

Pour comprendre cette courbe quadratique il faut se rappeler que les valeurs sont générés aléatoirement  entre $0$ et $50$, donc en moyenne la somme des valeurs $N$ est de $25n$. De ce fait $O(nN)$ correspond à $O(n^2)$, donc exactement ce que nous voyons apparaitre lors des tests.
