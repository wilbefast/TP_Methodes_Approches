\documentclass[a4paper, 12pt]{article}
%\usepackage[utf8]{inputenc} 
\usepackage[frenchb]{babel}
\usepackage{fullpage}
\usepackage[T1]{fontenc} 
\usepackage{graphicx}  
\usepackage[final]{pdfpages}
\usepackage{amsmath, amssymb,amsthm}
\usepackage{algorithm,algorithmic}
\usepackage{listingsutf8}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{pgfplots}

\newtheorem{mydef}{Définition}
\newtheorem{thm}{Théorème}
\newtheorem{lem}{Lemme}
\newtheorem{cor}{Corollaire}
\newtheorem{prop}{Propriété}

\title{Rapport de Méthodes approchées.}
\author{Dyce William, Loukil Amal, Ouazzani-chahdi Sabrina : \\ M1 MOCA}
\date{semestre 2 : 2011-2012}

\begin{document} 

\maketitle

\begin{abstract}
  Le présent document consiste en un mémoire au sujet
  d'exercices à la fois théoriques et pratiques sur diverses
  problèmatiques liées à l'étude de méthodes approchées pour la
  résolution de problèmes NP-difficiles. 
\end{abstract}
\vspace{2cm}
\textit{Travelling salesman's problem :}
\begin{figure}[h!]
\centering
\includegraphics[height = 9cm]{commerce.png}
\end{figure}


\pagebreak

\tableofcontents

\pagebreak

\listoffigures

\listoftables
\pagebreak

\section{Généralités et notations}

\pagebreak

\section{Partie théorique}

\subsection{Programmation linéaire en nombres entiers}

\subsubsection*{Exercice 1}
\input{ex1.tex}

\subsubsection*{Exercice 2}
\input{ex2.tex}

\subsubsection*{Exercice 3}
\input{ex3.tex}

\subsection{Problèmes appartenant à la classe APX}

\subsubsection*{Exercice 4}
\input{ex4.tex}

\subsection{Constructions de PTAS}

\subsubsection*{Exercice 5}
\input{ex5.tex}

\subsubsection*{Exercice 6}
\input{ex6.tex}

\subsection{Utilisation de méthodes exactes}

\subsubsection*{Exercice 7}
\input{ex7.tex}

\paragraph{Le problème du voyageur de commerce}

\subsubsection*{Exercice 8}
\input{ex8.tex}

\subsection{Méthode Primal-Dual}

\subsubsection*{Exercice 9}
\input{ex9.tex}

\subsection{Borne de non-approximation}

\subsubsection*{Exercice 10}
\input{ex10.tex}

\subsubsection*{Exercice 11}
\input{ex11.tex}

\subsubsection*{Exercice 12}

\pagebreak

\section{Partie pratique}

\subsection{Programmation dynamique}

Nous effectuerons ici les simulations du problème de la partition, du sac
à dos et du voyageur de commerce selon une implémentation
d'algorithmes basés sur de la programmation dynamique. Les programmes
seront écrits en langage C.

La programmation dynamique permet de trouver la solution optimale d'un
problème en combinant les solutions optimales de sous-problèmes de ce
problème.

\subsubsection{Sac à dos}

Nous avons commencé par nous intéresser au problème du sac à dos avant
partition car celui-ci est le plus général.

\paragraph{Modélisation}

Le problème du sac à dos se modélise en programmation linéaire de la
manière suivante~:

\begin{equation}
\begin{cases}
Max~z=\sum_{i=1}^nc_ix_i \\
\sum_{i=1}^na_ix_i \leq b \\
x_i \in\{0, 1\}, i=1\dots n\\
\end{cases}
\end{equation}

%Ainsi, nous prenons en paramètre~:
%\begin{itemize}
%\item le nombre $n$ d'objets sur lesquels nous
%désirons travailler, 
%\item le poids $b$ du sac que nous ne pouvons pas
%dépasser, 
%\item une variable binaire $x$, 
%\item un ensemble $C$ d'utilités à associer à chaque objet,
%\item un ensemble $A$ de poids à associer à chaque objet.
%\end{itemize}

\paragraph{Formules de programmation dynamique}

Les formules de programmation dynamique pour le problème du sac à dos
sont les suivantes~:
\begin{equation}
\begin{cases}
tab[0][w] = 0 \\
tab[i][j] = max(tab[i-1] [j], (tab[i-1] [j-poids[i]] + utilite[i])); \\
\end{cases}
\end{equation}

\paragraph{Implémentation en C}

Nous avons donc implémenté l'algorithme suivant (avec la fonction très
simple \textit{min} de calcul de minimum entre deux valeurs que nous
ne faisons pas figurer ici).

\begin{lstlisting}

int sacADos(int W, int* poids, int* utilite, int nbObjets){ 
//W represente la capacite max du sac

// tableau central de la programmation dynamique
int tab[nbObjets][W+1]; 
int w;

//initialisation de la table
for (w = 0; w < W + 1; w++){
  tab[0][w] = 0;
    }

//remplissage de la table selon les formules de la prog dyn
 int i, j;
 for (i = 1; i < nbObjets ; i++){
  for (j = 0; j < W + 1 ; j++) {
    if (j >= poids[i]) {
      tab[i][j] = max(tab[i-1] [j], 
(tab[i-1] [j-poids[i]] + utilite[i]));
    }
      else{
      tab[i][j] = tab[i-1] [j];
      }
    }
  }
//la valeur qui nous interesse
 printf(" poids : \%d \n", W);
 printf("meilleure solution (utilite) :
\%d \n", tab[nbObjets -1] [W]);
 return (tab[nbObjets -1] [W]);
}

\end{lstlisting}

\paragraph{Complexité théorique}

La complexité en temps de notre algorithme est en $O(nW)$. Il en va de
même pour la complexité mémoire.

\paragraph{Jeux de tests et temps d'exécution}

TODO

\subsubsection{Partition}

\paragraph{Modélisation}

Le problème de la partition se modélise de la manière suivante~:
\begin{equation}
\sum_{a \in A'} p(a)= \sum_{a \in A
    \backslash A'}p(a)
\end{equation}

\paragraph{Formules de programmation dynamique}

On se basera sur la récurrence suivante~:

\begin{equation}
\begin{cases}
tab[0] = 1; \\
si ( tab[j] == 1 ) {
       tab[j + poids[i]] = 1;
     } \\
\end{cases}
\end{equation}

\paragraph{Implémentation en C}

Nous présentons donc l'algorithme suivant, qui est une sorte de
restriction (cas particulier) de l'algorithme proposé pour la
résolution du problème du sac à dos~:

\begin{lstlisting}
int partition(int* poids, int nbObjets){ 


//calcul de la somme totale des poids
 int i, j;
int N = 0;
for(i = 0; i < nbObjets; i++ ) {N += poids[i];}

int tab[N]; 

//initialisation de la table de booleens

 tab[0] = 1;
 for(i = 1; i <= N; i ++ )  {tab[i] = 0;}


//remplissage de la table selon les formules de la prog dyn

 for(i = 0; i < nbObjets; i++ ){
   for(j = N - poids[i]; j >= 0; j-- ){
     if( tab[j] == 1 ) {
       tab[j + poids[i]] = 1;
     }
   }
 }

//la reponse qui nous interesse
 if(tab[N / 2] == 1){ 
   printf("vrai avec %d \n", N/2);
   }
 else{puts("faux");}

 return tab[N / 2];
}

\end{lstlisting}

\paragraph{Complexité théorique}

Soit $N$ la somme des poids.
La complexité en temps de notre algorithme est $O(nN)$.
La complexité mémoire est $O(N).$

\paragraph{Jeux de tests et temps d'exécution}

TODO

\subsubsection{Voyageur de commerce}

\paragraph{Modélisation}

Le problème du voyageur de commerce peut se modéliser de la manière
suivante~:


on se donne un graphe complet $K_n=(X,E)$ et on note $c_{ij}$ le poids
de l'arête $\{i,j\}$.
\begin{equation}
\begin{cases}
min \sum_{\{i, j\} \in E} c_{ij}.x_{ij} \\
\sum_{i=0}^n \sum_{j=0}^n x_{ij} = 1 \\
\forall (S, \bar{S}) \sum_{i \in S, j \in \bar{S}} x_{ij} \geq 1 \\
x_{ij} \in \{0, 1\} \\
\end{cases}
\end{equation}

\paragraph{Formules de programmation dynamique}

On note $C(S,i)$ la longueur d'une plus courte chaîne du sommet $0$ au
sommet $i$ qui passe une et une seule fois par tout sommet de $S$ et
qui n'utilise pas de sommet non dans $S$ autre que $i$. On a ainsi les
formules suivantes pour le problème du voyageur de commerce~:

\begin{equation}
\begin{cases}
C[S][i] = poids[0][i] \text{si S ne contient que $0$} \\
C[S][i] = min_{k \in S - \{ 0 \}} \{ C[S- \{ k \}][k] + poids[k][i]  \}
\end{cases}
\end{equation}

\paragraph{Implémentation en C}

TODO

\paragraph{Complexité théorique}

TODO

\paragraph{Jeux de tests et temps d'exécution}

TODO


\pagebreak

\subsection{Branch and bound}

Nous nous intéresserons au sein de cette section à la programmation de
la méthode de branch and bound pour résoudre le problème du voyageur
de commerce (tsp).

\subsubsection{Détermination de la solution initiale}

Dans cette partie, nous nous servirons de l'outil GLPK, et en
particulier de la syntaxe du langage Gnu MathProg. Pour le problème
présenté, un fichier .mod contenant la modélisation du problème est
créé ainsi qu'autant de fichiers .dat que de jeux de test. Nous nous
intéresserons à trois heuristiques en particulier.

\paragraph{Chaîne de poids le plus faible et ajout d'une arête pour le
  cycle}


\paragraph{Voisinage 2--opt}

\paragraph{Voisinage 3--opt}

\subsubsection{Programmation de l'algorithme $\frac{3}{2}$}

\paragraph{Principe de l'algorithme}

\paragraph{Complexité théorique}

\paragraph{Langage de programmation et bibliothèques}

\paragraph{Structures de données utilisées}

\paragraph{Principales fonctions}

\paragraph{Remarques}

\subsubsection{Tests}

\paragraph{Outils}

Nous utiliserons ici l'utilitaire console Unix time pour mesurer le
temps de calcul de nos programmes. Gprof sera également utilisé pour
une analyse un peu plus fine du temps de calcul (outil de profiling).

\paragraph{Tests de validité de notre programme}

\paragraph{Comparaison de l'efficacité de l'algorithme selon les
  trois heuristiques}


\paragraph{Comparaison entre la programmation dynamique et le branch and bound}

\subsection{Conclusion}

\end{document}
